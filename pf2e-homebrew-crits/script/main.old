// scripts/main.js
/* ------------------------------------------------------------------------- *
 * PF2e Homebrew Crits — V13 / PF2e 7.x
 *  - Visual banner (±5 DoS); nat-crit only for Untrained/Trained (d20: 17↑ / 3↓)
 *  - Engine Override (optional): write outcome/degree to flags
 *  - Proficiency Die Swap (optional): Expert=d16+4, Master=d12+8, Legendary=d10+10
 *    (scoped by kind + PCs-only; safe with Dice So Nice; offset applied once)
 *  - Discovery Mode + Trace Dice (optional)
 *  - No legacy colors when DC is missing; total number colored only for real nat-crits
 *  - Initiative: correct rank detection, PC-only gating respected on groups
 *  - Cosmetic: fix proficiency chip text to show the true rank (Expert/Master/etc.)
 * ------------------------------------------------------------------------- */

const NS = "pf2e-homebrew-crits";
const RANK = Object.freeze({ untrained: 0, trained: 1, expert: 2, master: 3, legendary: 4 });

/* -------------------------- Settings cache ------------------------------- */
const SettingsCache = {
  _cache: new Map(),
  _lastUpdate: 0,
  _ttl: 5000, // 5s TTL; onChange clears immediately.
  get(key) {
    const now = Date.now();
    if (now - this._lastUpdate > this._ttl) {
      this._cache.clear();
      this._lastUpdate = now;
    }
    if (!this._cache.has(key)) this._cache.set(key, game.settings.get(NS, key));
    return this._cache.get(key);
  },
  clear() { this._cache.clear(); this._lastUpdate = Date.now(); }
};

/* ------------------------------- Settings -------------------------------- */
Hooks.once("init", () => {
  console.log("[pf2e-homebrew-crits] Initializing module");

  const settings = [
    ["criticalHitValue", { name: "Critical Hit Value (d20 only)", hint: "Natural roll that displays as a critical success (d20 only).", scope: "world", config: true, type: Number, default: 17, range: { min: 2, max: 20, step: 1 }, onChange: () => SettingsCache.clear() }],
    ["criticalMissValue", { name: "Critical Failure Value (d20 only)", hint: "Natural roll that displays as a critical failure (d20 only).", scope: "world", config: true, type: Number, default: 3, range: { min: 1, max: 19, step: 1 }, onChange: () => SettingsCache.clear() }],
    ["dcThreshold", { name: "Degree-of-Success Threshold", hint: "Margin vs DC for Critical Success/Failure.", scope: "world", config: true, type: Number, default: 5, range: { min: 1, max: 10, step: 1 }, onChange: () => SettingsCache.clear() }],
    ["discoveryMode", { name: "Discovery Mode (PF2e DoS)", hint: "Logs where PF2e computes DoS and the roll plumbing.", scope: "client", config: true, type: Boolean, default: false }],
    ["engineOverride", { name: "Engine Override", hint: "Apply homebrew DoS (±5) to message flags; nat-crit U/T only.", scope: "world", config: true, type: Boolean, default: false }],
    ["dieSwapEnabled", { name: "Enable Proficiency Die Swap", hint: "Apply proficiency die swap by rank. See formulas below.", scope: "world", config: true, type: Boolean, default: false, onChange: () => SettingsCache.clear() }],
    ["dieSwapPCsOnly", { name: "Die Swap: PCs Only", hint: "Apply only to actors of type 'character'.", scope: "world", config: true, type: Boolean, default: true, onChange: () => SettingsCache.clear() }],
    ["dieSwapSkills", { name: "Die Swap: Skills", scope: "world", config: true, type: Boolean, default: true, onChange: () => SettingsCache.clear() }],
    ["dieSwapSaves", { name: "Die Swap: Saving Throws", scope: "world", config: true, type: Boolean, default: true, onChange: () => SettingsCache.clear() }],
    ["dieSwapPerception", { name: "Die Swap: Perception", scope: "world", config: true, type: Boolean, default: true, onChange: () => SettingsCache.clear() }],
    ["dieSwapInitiative", { name: "Die Swap: Initiative", scope: "world", config: true, type: Boolean, default: true, onChange: () => SettingsCache.clear() }],
    ["dieSwapStrikes", { name: "Die Swap: Strikes (beta)", hint: "Experimental; off by default.", scope: "world", config: true, type: Boolean, default: false, onChange: () => SettingsCache.clear() }],
    ["traceDice", { name: "Trace Dice Plumbing (very verbose)", hint: "Logs formula → terms → evaluate with IDs & stacks.", scope: "client", config: true, type: Boolean, default: false }],
    ["dieSwapFormulaUntrained", { name: "Formula — Untrained", hint: "Format: dX + N (spaces optional). Example: d20+0", scope: "world", config: true, type: String, default: "d20+0", onChange: () => SettingsCache.clear() }],
    ["dieSwapFormulaTrained", { name: "Formula — Trained", hint: "Format: dX + N. Example: d20+0", scope: "world", config: true, type: String, default: "d20+0", onChange: () => SettingsCache.clear() }],
    ["dieSwapFormulaExpert", { name: "Formula — Expert", hint: "Format: dX + N. Example: d16+4", scope: "world", config: true, type: String, default: "d16+4", onChange: () => SettingsCache.clear() }],
    ["dieSwapFormulaMaster", { name: "Formula — Master", hint: "Format: dX + N. Example: d12+8", scope: "world", config: true, type: String, default: "d12+8", onChange: () => SettingsCache.clear() }],
    ["dieSwapFormulaLegendary", { name: "Formula — Legendary", hint: "Format: dX + N. Example: d10+10", scope: "world", config: true, type: String, default: "d10+10", onChange: () => SettingsCache.clear() }],
  ];

  const DieSwapFormulas = {
    keys: [
      "dieSwapFormulaUntrained",
      "dieSwapFormulaTrained",
      "dieSwapFormulaExpert",
      "dieSwapFormulaMaster",
      "dieSwapFormulaLegendary",
    ],
    labels: ["Untrained", "Trained", "Expert", "Master", "Legendary"],

    // Read values from DOM if available (live preview), otherwise from settings.
    readAll(html) {
      const vals = [];
      for (let i = 0; i < this.keys.length; i++) {
        const k = this.keys[i];
        const domVal = html?.find?.(`input[name="${NS}.${k}"]`).val?.();
        const v = (typeof domVal === "string" && domVal.trim().length) ? domVal.trim() : SettingsCache.get(k);
        vals.push(v);
      }
      return vals;
    },

    buildSummary(vals) {
      return this.labels.map((lab, i) => `${lab}=${String(vals[i] || "").replace(/\s+/g, "")}`).join(", ");
    },
  };

  for (const [key, data] of settings) game.settings.register(NS, key, data);
});

/* -------------------------------- Utils --------------------------------- */
const Utils = {
  degreeFromDiff(d, thr) { if (d >= thr) return 3; if (d >= 0) return 2; if (d <= -thr) return 0; return 1; },
  labelFor(deg) { return ["Critical Failure", "Failure", "Success", "Critical Success"][deg] ?? "—"; },
  outcomeFor(deg) { return ["criticalFailure", "failure", "success", "criticalSuccess"][deg] ?? null; },

  termsAPI() {
    if (!this._termsAPI) {
      const t = foundry?.dice?.terms ?? CONFIG?.Dice?.terms ?? CONFIG?.Dice?.termTypes ?? {};
      this._termsAPI = {
        Die: t.Die ?? t.DiceTerm ?? globalThis.Die ?? null,
        OperatorTerm: t.OperatorTerm ?? t.O ?? globalThis.OperatorTerm ?? null,
        NumericTerm: t.NumericTerm ?? t.N ?? globalThis.NumericTerm ?? null,
      };
    }
    return this._termsAPI;
  },
  parseSwapFormula(str) {
    if (typeof str !== "string") return null;
    const s = str.replace(/\s+/g, "").toLowerCase(); // e.g. "d16+4" / "d12-1"
    const m = /^d(\d+)([+\-]\d+)?$/.exec(s);
    if (!m) return null;
    const faces = Number(m[1]);
    const offset = m[2] ? Number(m[2]) : 0;
    if (!Number.isFinite(faces) || faces < 2 || faces > 1000) return null;
    if (!Number.isFinite(offset)) return null;
    return { faces, offset };
  },

  firstDieFromRoll(roll) {
    const terms = Array.isArray(roll?.terms) ? roll.terms.flat(Infinity) : [];
    const die = terms.find(x => x && typeof x.faces === "number" && Array.isArray(x.results));
    const faces = die?.faces ?? null;
    const nat = Array.isArray(die?.results) && die.results.length ? die.results[0]?.result : null;
    return { faces, nat };
  },

  isTermEvaluated(t) {
    if (!t) return false;
    if (typeof t.isEvaluated === "boolean") return t.isEvaluated;
    if (typeof t._evaluated === "boolean") return t._evaluated;
    if (Array.isArray(t.results) && t.results.length) return true;
    if (Array.isArray(t.terms)) return t.terms.some(this.isTermEvaluated.bind(this));
    return false;
  },
  anyTermsEvaluated(terms) { return Array.isArray(terms) && terms.some(this.isTermEvaluated.bind(this)); },

  mutateDieFacesRec(term, fromFaces, toFaces) {
    if (!term) return;
    if (typeof term.faces === "number" && term.faces === fromFaces) term.faces = toFaces;
    if (Array.isArray(term.terms)) for (const st of term.terms) this.mutateDieFacesRec(st, fromFaces, toFaces);
  },
  appendOffsetTopLevel(roll, offset) {
    if (!offset || !roll?.terms) return;
    const { OperatorTerm, NumericTerm } = this.termsAPI();
    if (OperatorTerm && NumericTerm) roll.terms.push(new OperatorTerm({ operator: "+" }), new NumericTerm({ number: offset }));
  },
  safeJSONStringify(v) { try { return JSON.parse(JSON.stringify(v)); } catch { return v; } },

  // Actor helpers (handles TokenDocumentPF2e or ActorPF2e)
  actorDoc(a) { return a?.actor ?? a ?? null; },
  actorSystem(a) { const ad = this.actorDoc(a); return ad?.system ?? null; },
};

/* --------------------------- Stat detection ------------------------------ */
const StatDetection = {
  fromDocument(doc) {
    try {
      const ctx = doc?.flags?.pf2e?.context;
      if (!ctx) return { kind: null, slug: null, rank: null, actor: null };
      const actor = Utils.actorDoc(game.actors?.get?.(ctx.actor) ?? null);
      const result = this.detectCore(actor, ctx.options, ctx.domains, ctx.type);

      // ADD THIS DEBUG LINE:
      console.log("[DEBUG] fromDocument result:", result, "ctx:", ctx);

      return result;
    } catch (err) {
      console.error("[pf2e-homebrew-crits] stat-from-doc error:", err);
      return { kind: null, slug: null, rank: null, actor: null };
    }
  },

  fromPreRoll(actorInput, context, check) {
    try {
      const actor = Utils.actorDoc(actorInput);
      const slug = String(check?.slug ?? "").toLowerCase();
      const opts = Array.isArray(context?.options) ? context.options : [];
      const doms = Array.isArray(context?.domains) ? context.domains : [];
      const typ = String(context?.type ?? "").toLowerCase();

      if (slug) {
        if (["fortitude", "reflex", "will"].includes(slug))
          return { kind: "save", slug, rank: Utils.actorSystem(actor)?.saves?.[slug]?.rank ?? null, actor };
        if (slug === "perception")
          return { kind: (typ === "initiative" ? "initiative" : "perception"), slug, rank: Utils.actorSystem(actor)?.perception?.rank ?? null, actor };
        if (Utils.actorSystem(actor)?.skills?.[slug])
          return { kind: "skill", slug, rank: Utils.actorSystem(actor).skills[slug].rank ?? null, actor };
      }
      return this.detectCore(actor, opts, doms, typ);
    } catch (err) { console.error("[pf2e-homebrew-crits] stat-pre error:", err); return { kind: null, slug: null, rank: null, actor: null }; }
  },

  detectCore(actor, options = [], domains = [], type = "") {
    // Saves: look for explicit save signals
    const saves = ["fortitude", "reflex", "will"];
    const foundSave = saves.find(sv =>
      domains.includes(sv) || domains.includes(`${sv}-check`) || options.includes(sv) || options.includes(`${sv}-check`)
    );
    if (foundSave) {
      return { kind: "save", slug: foundSave, rank: Utils.actorSystem(actor)?.saves?.[foundSave]?.rank ?? null, actor };
    }

    // Perception / Initiative
    if (type === "initiative" || options.includes("perception-check") || type === "perception-check" || domains.includes("perception")) {
      return { kind: (type === "initiative" ? "initiative" : "perception"), slug: "perception", rank: Utils.actorSystem(actor)?.perception?.rank ?? null, actor };
    }

    // Skills: check for "check:statistic:SKILLNAME" pattern first
    const statCheck = options.find(o => o.startsWith("check:statistic:"));
    if (statCheck && Utils.actorSystem(actor)?.skills) {
      const slug = statCheck.replace("check:statistic:", "");
      const stat = Utils.actorSystem(actor).skills[slug];
      if (stat) return { kind: "skill", slug, rank: stat.rank ?? null, actor };
    }

    // Skills: fallback to old "-check" pattern
    const sk = options.find(o => o.endsWith("-check") && !["fortitude-check", "reflex-check", "will-check", "perception-check"].includes(o));
    if (sk && Utils.actorSystem(actor)?.skills) {
      const slug = sk.replace("-check", "");
      const stat = Utils.actorSystem(actor).skills[slug];
      if (stat) return { kind: "skill", slug, rank: stat.rank ?? null, actor };
    }

    // Skills: ALSO check domains for "SKILLNAME-check" pattern
    const domainSkill = domains.find(d => d.endsWith("-check") && !["fortitude-check", "reflex-check", "will-check", "perception-check"].includes(d));
    if (domainSkill && Utils.actorSystem(actor)?.skills) {
      const slug = domainSkill.replace("-check", "");
      const stat = Utils.actorSystem(actor).skills[slug];
      if (stat) return { kind: "skill", slug, rank: stat.rank ?? null, actor };
    }

    // Strikes: extract proficiency rank
    if (type === "attack-roll" || domains.includes("attack") || options.includes("attack-roll") || options.includes("strike-attack-roll")) {
      // Try to extract rank from options like "item:proficiency:rank:2"
      let rank = null;
      const profOpt = options.find(o => o.startsWith("item:proficiency:rank:"));
      if (profOpt) {
        const rankNum = parseInt(profOpt.replace("item:proficiency:rank:", ""), 10);
        if (Number.isInteger(rankNum)) rank = rankNum;
      }

      // Fallback: look for domain patterns like "expert-attack", "master-attack", "legendary-attack"
      if (rank === null) {
        if (domains.includes("legendary-attack")) rank = 4;
        else if (domains.includes("master-attack")) rank = 3;
        else if (domains.includes("expert-attack")) rank = 2;
        else if (domains.includes("trained-attack")) rank = 1;
        else if (domains.includes("untrained-attack")) rank = 0;
      }

      return { kind: "strike", slug: "strike", rank, actor };
    }

    return { kind: null, slug: null, rank: null, actor: null };
  }
};

/* ---------------------------- Proficiency -------------------------------- */
const Proficiency = {
  allowNatCrit(faces, nat, rank) {
    if (faces !== 20 || !Number.isInteger(nat)) return false;
    if (rank === null || rank === undefined) return true; // unknown rank → don't block
    return rank <= RANK.trained;                            // only U/T get nat crit bumps
  },
  specForRank(rank) {
    const keyByRank = [
      "dieSwapFormulaUntrained",
      "dieSwapFormulaTrained",
      "dieSwapFormulaExpert",
      "dieSwapFormulaMaster",
      "dieSwapFormulaLegendary",
    ];
    const key = keyByRank[rank];
    if (!key) return null;

    const spec = Utils.parseSwapFormula(SettingsCache.get(key));
    if (!spec) return null;

    // Treat d20+0 as a no-op so U/T remain native by default
    if (spec.faces === 20 && (spec.offset | 0) === 0) return null;

    return spec; // {faces, offset}
  },

  shouldApplyDieSwap(kind, actorInput, rank) {
    const actor = Utils.actorDoc(actorInput);
    if (!SettingsCache.get("dieSwapEnabled")) return false;
    if (SettingsCache.get("dieSwapPCsOnly") && actor?.type !== "character") return false; // NPCs blocked here
    const gates = {
      skill: SettingsCache.get("dieSwapSkills"),
      save: SettingsCache.get("dieSwapSaves"),
      perception: SettingsCache.get("dieSwapPerception"),
      initiative: SettingsCache.get("dieSwapInitiative"),
      strike: SettingsCache.get("dieSwapStrikes"),
    };
    if (!gates[kind]) return false;
    return !!this.specForRank(rank);
  },
};
/* -------------------------- Dynamic formula in settings ------------------------------- */
// --- Dynamic summary for Die Swap formulas in Settings UI ---
Hooks.on("renderSettingsConfig", (app, htmlNode) => {
  try {
    const $html = (window.jQuery && htmlNode instanceof jQuery) ? htmlNode : $(htmlNode);

    // Find the row of the "Enable Proficiency Die Swap" toggle
    const $row = $html.find(`input[name="${NS}.dieSwapEnabled"]`).closest(".form-group");
    if (!$row.length) return;

    const $hint = $row.find(".hint");

    const render = () => {
      // Read current inputs if present, else fall back to saved settings
      const vals = [
        "dieSwapFormulaUntrained",
        "dieSwapFormulaTrained",
        "dieSwapFormulaExpert",
        "dieSwapFormulaMaster",
        "dieSwapFormulaLegendary",
      ].map(k => {
        const $inp = $html.find(`input[name="${NS}.${k}"]`);
        const v = $inp.length ? String($inp.val() ?? "").trim() : "";
        return v || SettingsCache.get(k);
      });

      const labels = ["Untrained", "Trained", "Expert", "Master", "Legendary"];
      const summary = labels.map((lab, i) => `${lab}=${String(vals[i]).replace(/\s+/g, "")}`).join(", ");

      $hint.html(`Apply proficiency die swap by rank.<br>Current formulas: <code>${summary}</code>`);
    };

    render();
    for (const k of ["dieSwapFormulaUntrained", "dieSwapFormulaTrained", "dieSwapFormulaExpert", "dieSwapFormulaMaster", "dieSwapFormulaLegendary"]) {
      $html.find(`input[name="${NS}.${k}"]`).off(".hbcrit").on("input.hbcrit change.hbcrit", render);
    }
  } catch (e) {
    console.warn("[pf2e-homebrew-crits] settings summary render failed:", e);
  }
});


/* -------------------------- Chat rendering ------------------------------- */
const ChatRenderer = {
  renderMessage(message, html) {
    try {
      const $root = html instanceof jQuery ? html : $(html);
      const rolls = message?.rolls ?? [];
      if (!Array.isArray(rolls) || rolls.length === 0) return;

      const dc = message?.flags?.pf2e?.context?.dc?.value ?? null;

      // Strip PF2e colors on no DC (root + totals); always remove crit classes.
      const stripColors = ($el) => $el.removeClass("success failure critical-success critical-failure");
      const $totals = $root.find(".dice-total, .roll-total, .total");
      if (dc == null) { stripColors($root); stripColors($totals); }
      else { $root.removeClass("critical-success critical-failure"); $totals.removeClass("critical-success critical-failure"); }

      const det = StatDetection.fromDocument(message);
      const specUsed = (Proficiency.shouldApplyDieSwap(det.kind, det.actor, det.rank)
        ? Proficiency.specForRank(det.rank)
        : null);

      for (const roll of rolls) {
        this.processRoll($root, $totals, roll, dc, det.rank, specUsed);
      }

    } catch (err) { console.error("[pf2e-homebrew-crits] render error:", err); }
  },

  processRoll($root, $totals, roll, dc, rank, specUsed) {
    const total = typeof roll.total === "number" ? roll.total : null;
    const { faces, nat } = Utils.firstDieFromRoll(roll);
    const thr = SettingsCache.get("dcThreshold");
    const critHitNat = SettingsCache.get("criticalHitValue");
    const critMissNat = SettingsCache.get("criticalMissValue");
    const specFromRoll = roll?.__pf2eHB_spec ?? null;
    const effectiveSpec = specFromRoll ?? specUsed ?? null;
    const offsetUsed = effectiveSpec ? (effectiveSpec.offset | 0) : 0;

    this.updateFormulaDisplay($root, nat, total, faces, offsetUsed);

    // DoS banner if DC present
    let dosLabel = null, dosColor = null;
    if (total != null && dc != null) {
      const diff = total - dc;
      const deg = Utils.degreeFromDiff(diff, thr);
      dosLabel = `${Utils.labelFor(deg)} by ${Math.abs(diff)}`;
      dosColor = ["red", "orange", "blue", "green"][deg] || "gray";
    }

    // Nat-crit coloring (U/T only)
    let natCritTag = "";
    const isNatUp = Proficiency.allowNatCrit(faces, nat, rank) && nat === critHitNat;
    const isNatDown = Proficiency.allowNatCrit(faces, nat, rank) && nat === critMissNat;
    if (isNatUp) natCritTag = `<span style="color:green;">(Crit)</span>`;
    if (isNatDown) natCritTag = `<span style="color:red;">(Crit)</span>`;
    if (isNatUp) { $root.addClass("critical-success"); $totals.addClass("critical-success"); }
    if (isNatDown) { $root.addClass("critical-failure"); $totals.addClass("critical-failure"); }

    // Build banner
    const dcPart = (dc != null) ? ` vs DC ${dc}` : "";
    const line1 = (Number.isInteger(nat) && faces) ? `d${faces} roll: ${nat}${natCritTag ? ` ${natCritTag}` : ""}` : "";
    const line2 = (total != null) ? `Total: ${total}${dcPart}` : `Total: —`;

    // Fix proficiency chip text to match true rank (helps when PF2e shows "Trained +2" by mistake)
    this.fixProficiencyChip($root, rank);

    const color = dosColor ?? "gray";
    const labelText = dosLabel ?? (dc == null ? "DC not found" : "");
    const banner =
      `<div style="margin-bottom:4px;padding:4px;border-left:4px solid ${color};">
         <div>${line1}</div>
         <div><b style="color:${color};">${labelText}</b></div>
         <div style="font-size:0.9em;color:#666;">${line2}</div>
       </div>`;
    $root.find(".message-content").prepend(banner);

    const $dos = $root.find(".degree-of-success");
    if ($dos.length && dosLabel) {
      $dos.html(`Result: <span style="color:${color};font-weight:bold;">${dosLabel}${natCritTag ? ` ${natCritTag}` : ""}</span>`);
    }
  },

  updateFormulaDisplay($root, nat, total, faces, offsetUsed = 0) {
    try {
      if (!Number.isInteger(nat) || typeof total !== "number" || !faces) return;

      const off = offsetUsed | 0;
      const rest = total - (nat + off); // everything except die + offset

      // Show the natural if the die is not d20 or an offset is applied
      const showNat = (faces !== 20) || off !== 0;
      const first = showNat ? `1d${faces}(${nat})` : `1d${faces}`;

      const parts = [first];
      if (off) parts.push(`<span class="hb-offset"> + ${off}</span>`);
      if (rest) parts.push(rest > 0 ? ` + ${rest}` : ` - ${Math.abs(rest)}`);

      const html = parts.join("");

      const $formula = $root.find(
        ".dice-roll .dice-formula, .dice-roll .roll-formula, .dice-formula, .roll-formula"
      ).first();

      if ($formula.length) {
        if ($formula.is("input, textarea")) {
          // strip tags for inputs
          $formula.val(html.replace(/<[^>]+>/g, ""));
        } else {
          $formula.html(html);
          // inject style once per page
          if (!$('style[data-hb-crits]').length) {
            $('body').append(
              `<style data-hb-crits>
                 .hb-offset{color:#00bcd4;font-weight:600}
               </style>`
            );
          }
        }
      }
    } catch (e) {
      console.warn("[pf2e-homebrew-crits] formula rewrite failed:", e);
    }
  },

  fixProficiencyChip($root, rank) {
    if (rank == null) return;
    const labelMap = ["Untrained", "Trained", "Expert", "Master", "Legendary"];
    const bonusMap = [0, 2, 4, 6, 8];
    const desired = `${labelMap[rank]} +${bonusMap[rank]}`;

    // look for a chip/tag that prints a rank label
    const $candidates = $root.find(".tags .tag, .tags .chip, .modifiers .tag, .pf2e-tag");
    $candidates.each(function () {
      const txt = $(this).text().trim();
      if (/^(Untrained|Trained|Expert|Master|Legendary)\s*\+\d+/.test(txt)) {
        $(this).text(desired);
        return false; // stop after the first one
      }
    });
  }
};
Hooks.on("renderChatMessageHTML", (message, html) => ChatRenderer.renderMessage(message, html));

/* ---------------------------- Engine override ---------------------------- */
const EngineOverride = {
  async processMessage(doc) {
    try {
      if (!SettingsCache.get("engineOverride")) return;
      const ctx = doc?.flags?.pf2e?.context; if (!ctx) return;

      const dc = ctx?.dc?.value;
      const roll = doc.rolls?.[0];
      if (dc == null || !roll) return;

      const total = typeof roll.total === "number" ? roll.total : null;
      if (total == null) return;

      const { faces, nat } = Utils.firstDieFromRoll(roll);
      const { rank } = StatDetection.fromDocument(doc);

      const thr = SettingsCache.get("dcThreshold");
      const critHitNat = SettingsCache.get("criticalHitValue");
      const critMissNat = SettingsCache.get("criticalMissValue");

      let deg = Utils.degreeFromDiff(total - dc, thr);
      if (Proficiency.allowNatCrit(faces, nat, rank)) {
        if (nat === critHitNat) deg = Math.min(3, deg + 1);
        if (nat === critMissNat) deg = Math.max(0, deg - 1);
      }

      const outcome = Utils.outcomeFor(deg);
      if (!outcome) return;
      if ((ctx?.outcome ?? null) !== outcome) {
        await doc.update({
          "flags.pf2e.context.outcome": outcome,
          "flags.pf2e.context.degreeOfSuccess": deg
        }).catch(err => console.error("[pf2e-homebrew-crits] flag update failed:", err));
      }
    } catch (e) { console.error("[pf2e-homebrew-crits] engine override error:", e); }
  }
};
Hooks.on("createChatMessage", (doc) => EngineOverride.processMessage(doc));

/* ---------------------------- Discovery mode ----------------------------- */
const DiscoveryMode = {
  init() {
    if (!SettingsCache.get("discoveryMode")) return;
    console.group("%c[DoS Discovery] PF2e", "color:#0aa");
    console.log("Foundry:", game.release?.version, "Build:", game.release?.build);
    console.log("System:", game.system?.id, "Version:", game.system?.version, "PF2e obj:", !!game.pf2e);
    console.groupEnd();

    Hooks.on("preCreateChatMessage", (doc, data) => {
      if (!data?.flags?.pf2e) return;
      console.groupCollapsed("%c[DoS Discovery] preCreateChatMessage flags.pf2e", "color:#0aa");
      console.log(Utils.safeJSONStringify(data.flags.pf2e));
      console.groupEnd();
    });
    Hooks.on("createChatMessage", (doc) => {
      const f = doc?.flags?.pf2e; if (!f) return;
      console.groupCollapsed("%c[DoS Discovery] createChatMessage flags.pf2e", "color:#0aa");
      console.log("stat/rank:", StatDetection.fromDocument(doc));
      console.log("context:", Utils.safeJSONStringify(f.context));
      console.groupEnd();
    });
  }
};
Hooks.once("ready", () => DiscoveryMode.init());

/* ---------------------------- Trace dice (opt) --------------------------- */
const DiceTracer = {
  traceStack: [],
  mkId() { return crypto?.randomUUID?.() ?? `${Date.now().toString(36)}${Math.random().toString(36).slice(2, 8)}`; },
  currentId() { return this.traceStack[this.traceStack.length - 1] || this.mkId(); },
  start(label, id, color = "#09c") { console.groupCollapsed(`%c[Trace:${id}] ${label}`, `color:${color}`); },
  end() { try { console.groupEnd(); } catch { }; },

  init() {
    if (!SettingsCache.get("traceDice")) return;

    // pf2e.Check.roll
    if (game?.pf2e?.Check?.roll) {
      const orig = game.pf2e.Check.roll;
      game.pf2e.Check.roll = async function (...args) {
        const id = DiceTracer.mkId(); DiceTracer.traceStack.push(id);
        DiceTracer.start("pf2e.Check.roll()", id);
        console.log("args[0] (check):", Utils.safeJSONStringify(args[0]));
        console.log("args[1] (context):", Utils.safeJSONStringify(args[1]));
        console.log("stack:"); console.trace(); DiceTracer.end();
        try { return await orig.apply(this, args); } finally { DiceTracer.traceStack.pop(); }
      };
      console.log("[Trace] Wrapped pf2e.Check.roll");
    }

    // Roll.fromFormula (tracer only; do NOT mutate here)
    if (typeof Roll.fromFormula === "function") {
      const orig = Roll.fromFormula;
      Roll.fromFormula = async function (formula, data, options) {
        const id = DiceTracer.currentId();
        DiceTracer.start("Roll.fromFormula()", id);
        console.log("formula(in):", formula);
        console.log("options:", Utils.safeJSONStringify(options));
        console.log("stack:"); console.trace();
        DiceTracer.end();

        const roll = await orig.call(this, formula, data, options);

        DiceTracer.start("Roll.fromFormula() -> Roll", id);
        console.log("roll.formula:", roll?.formula);
        console.log("roll.terms:", roll?.terms);
        DiceTracer.end();

        return roll;
      };
      console.log("[Trace] Wrapped Roll.fromFormula");
    }


    // Roll.fromTerms
    if (typeof Roll.fromTerms === "function") {
      const orig = Roll.fromTerms;
      Roll.fromTerms = function (terms, data) {
        const id = DiceTracer.currentId();
        DiceTracer.start("Roll.fromTerms()", id); console.log("terms(in):", terms); console.log("stack:"); console.trace(); DiceTracer.end();
        const roll = orig.call(this, terms, data);
        DiceTracer.start("Roll.fromTerms() -> Roll", id); console.log("roll.formula:", roll?.formula); console.log("roll.terms:", roll?.terms); DiceTracer.end();
        return roll;
      };
      console.log("[Trace] Wrapped Roll.fromTerms");
    }

    // evaluate / evaluateSync
    for (const name of ["evaluate", "evaluateSync"]) {
      const orig = Roll.prototype[name];
      if (typeof orig !== "function") continue;
      Roll.prototype[name] = async function (...args) {
        const id = DiceTracer.currentId();
        DiceTracer.start(`Roll.${name}()`, id, "#0a6"); console.log("formula(before):", this?.formula); console.log("terms(before):", this?.terms); DiceTracer.end();
        const out = await orig.apply(this, args);
        DiceTracer.start(`Roll.${name}() -> done`, id, "#0a6"); console.log("formula(after):", this?.formula); console.log("terms(after):", this?.terms); DiceTracer.end();
        return out;
      };
      console.log(`[Trace] Wrapped Roll.${name}`);
    }

    // Die.evaluate
    const Die = Utils.termsAPI().Die;
    if (Die?.prototype?.evaluate) {
      const orig = Die.prototype.evaluate;
      Die.prototype.evaluate = async function (...args) {
        const id = DiceTracer.currentId();
        DiceTracer.start("Die.evaluate()", id, "#b50"); console.log("faces(before):", this?.faces, "number:", this?.number); console.log("this:", this); console.log("stack:"); console.trace(); DiceTracer.end();
        const out = await orig.apply(this, args);
        DiceTracer.start("Die.evaluate() -> done", id, "#b50"); console.log("faces(after):", this?.faces, "results:", this?.results); DiceTracer.end();
        return out;
      };
      console.log("[Trace] Wrapped Die.evaluate");
    }

    console.info("%c[Trace] Dice tracing enabled — roll and inspect the console.", "color:#09c");
  }
};
Hooks.once("ready", () => DiceTracer.init());

/* ------------------------ Proficiency die swap --------------------------- */
Hooks.once("ready", () => {
  if (!SettingsCache.get("dieSwapEnabled")) return;

  const Check = game?.pf2e?.Check;
  if (!Check || typeof Check.roll !== "function") {
    console.warn("[pf2e-homebrew-crits] DieSwap: game.pf2e.Check.roll not found.");
    return;
  }

  const lib = game.modules.get("lib-wrapper");
  const register = (fn) => {
    try {
      if (lib?.active && globalThis.libWrapper?.register) {
        // libWrapper v1.13.x expects a string target path
        globalThis.libWrapper.register(NS, "game.pf2e.Check.roll", fn, "MIXED");
        console.log("[pf2e-homebrew-crits] DieSwap registered via libWrapper (string target).");
      } else {
        const orig = Check.roll; Check.roll = function (...args) { return fn(orig.bind(this), ...args); };
        console.log("[pf2e-homebrew-crits] DieSwap registered (fallback patch).");
      }
    } catch (e) {
      console.warn("[pf2e-homebrew-crits] DieSwap registration failed; falling back:", e);
      try { const orig = Check.roll; Check.roll = function (...args) { return fn(orig.bind(this), ...args); }; }
      catch (e2) { console.error("[pf2e-homebrew-crits] DieSwap fallback failed:", e2); }
    }
  };

  // one-shot state while a single Check.roll is in-flight
  const swapStack = [];

  // ---- Patch A: DieTerm.evaluate (earliest) ----
  const { Die } = Utils.termsAPI();
  let diePatched = false, dieOrig = null;
  function installDiePatch() {
    if (diePatched || !Die || typeof Die.prototype?.evaluate !== "function") return;
    dieOrig = Die.prototype.evaluate;
    Die.prototype.evaluate = async function (...args) {
      const spec = swapStack[swapStack.length - 1];
      try { if (spec && this?.faces === 20) this.faces = spec.faces; } catch { }
      return await dieOrig.apply(this, args);
    };
    diePatched = true;
  }
  function removeDiePatch() { if (diePatched && dieOrig) Die.prototype.evaluate = dieOrig; dieOrig = null; diePatched = false; }

  // ---- Patch B: Roll.fromTerms (swap faces; add +offset if terms are not yet evaluated) ----
  // ---- Patch B: Roll.fromTerms (swap faces; add +offset if terms are not yet evaluated) ----
  let fromPatched = false;
  const fromOrig = {};

  function installFromTermsPatch() {
    if (fromPatched) return;

    const applyTo = (Host, label) => {
      if (!Host || typeof Host.fromTerms !== "function" || fromOrig[label]) return;

      const orig = Host.fromTerms;
      fromOrig[label] = orig;

      Host.fromTerms = function (terms, data) {
        // CRITICAL: Only apply spec if explicitly passed through data._pf2eHB
        // Do NOT grab from stack - that causes cross-contamination with Dice So Nice
        const currentSpec = data?._pf2eHB?.spec || null;

        if (currentSpec && !Utils.anyTermsEvaluated(terms)) {
          try {
            const touch = (t) => {
              if (!t) return;
              if (typeof t.faces === "number" && t.faces === 20) t.faces = currentSpec.faces;
              if (Array.isArray(t.terms)) t.terms.forEach(touch);
              if (Array.isArray(t.rolls)) t.rolls.forEach(touch);
            };
            (Array.isArray(terms) ? terms : []).forEach(touch);

            if (!currentSpec._offsetApplied && currentSpec.offset) {
              Utils.appendOffsetTopLevel({ terms }, currentSpec.offset);
              currentSpec._offsetApplied = true;
            }
          } catch (e) {
            console.warn("[pf2e-homebrew-crits] fromTerms swap error:", e);
          }
        }

        const roll = orig.call(this, terms, data);
        try {
          if (currentSpec) roll.__pf2eHB_spec = { ...currentSpec };
        } catch { }

        return roll;
      };
    };

    applyTo(Roll, "Roll");
    applyTo(game?.pf2e?.CheckRoll, "CheckRoll");
    fromPatched = true;
  }

  function removeFromTermsPatch() {
    if (fromPatched) {
      if (fromOrig.Roll) Roll.fromTerms = fromOrig.Roll;
      if (fromOrig.CheckRoll && game?.pf2e?.CheckRoll) game.pf2e.CheckRoll.fromTerms = fromOrig.CheckRoll;
    }
    fromPatched = false;
    fromOrig.Roll = fromOrig.CheckRoll = undefined;
  }

  function removeEvaluatePatch() {
    if (!evaluatePatched) return;
    const proto = Roll.prototype;
    for (const name of ["evaluate", "evaluateSync"]) {
      if (evalOrig[name]) {
        proto[name] = evalOrig[name];
        evalOrig[name] = undefined;
      }
    }
    evaluatePatched = false;
  }


  // ---- Patch C: Roll.fromFormula (replace d20 → dX; add +offset; tag the roll) ----
  let formulaPatched = false;
  let fromFormulaOrig = null;
  function installFromFormulaPatch() {
    if (formulaPatched || typeof Roll.fromFormula !== "function") return;
    fromFormulaOrig = Roll.fromFormula;

    Roll.fromFormula = async function (formula, data, options) {
      const currentSpec = options?._pf2eHB?.spec || swapStack[swapStack.length - 1] || null;

      if (currentSpec) {
        const newFormula = String(formula).replace(
          /(\D|^)(\d*)d20(?!\d)/gi,
          (_, pre, num) => `${pre}${num || "1"}d${currentSpec.faces}`
        );

        const roll = await fromFormulaOrig.call(this, newFormula, data, options);
        try { roll.__pf2eHB_spec = { ...currentSpec }; } catch { }
        return roll;
      }
      return await fromFormulaOrig.call(this, formula, data, options);
    };

    formulaPatched = true;
  }


  function removeFromFormulaPatch() {
    if (!formulaPatched) return;
    if (fromFormulaOrig) Roll.fromFormula = fromFormulaOrig;
    fromFormulaOrig = null;
    formulaPatched = false;
  }

  // ---- Patch D: Roll.prototype.evaluate / evaluateSync (inject +offset as term; last-chance face swap) ----
  let evaluatePatched = false;
  const evalOrig = {}; // keep originals so we can remove later

  function installEvaluatePatch() {
    if (evaluatePatched) return;

    const proto = Roll.prototype;
    const fnNames = ["evaluate", "evaluateSync"];
    const Terms = (foundry?.dice?.terms) || (CONFIG?.Dice?.terms) || {};

    for (const name of fnNames) {
      const original = proto[name];
      if (typeof original !== "function") continue;
      if (original.__pf2eHB_patched) continue;

      evalOrig[name] = original;

      proto[name] = function (...args) {
        // Prefer the per-roll tag; fall back to the currently active spec on the stack
        const spec = this?.__pf2eHB_spec ?? (swapStack[swapStack.length - 1] || null);

        try {
          // --- Last-chance faces swap for any leftover d20 dice terms ---
          if (spec?.faces && !this.__pf2eHB_facesApplied && Array.isArray(this.terms)) {
            for (const t of this.terms) {
              const isDiceTerm =
                (Terms.DiceTerm && t instanceof Terms.DiceTerm) ||
                (t?.constructor?.name === "DiceTerm" || t?.class === "DiceTerm");
              if (isDiceTerm && String(t.faces) === "20") {
                t.number = t.number ?? 1;
                t.faces = spec.faces;
              }
            }
            this._formula = null; // we will re-cache a string below
            this.__pf2eHB_facesApplied = true;
          }

          // --- Inject +offset as a distinct NumericTerm so the card shows it ---
          // Guard also against spec._offsetApplied from Patch B to prevent doubles
          if (
            spec?.offset &&
            !spec._offsetApplied &&
            !this.__pf2eHB_offsetApplied &&
            Array.isArray(this.terms) &&
            this.terms.length > 0
          ) {
            const opTerm = Terms.OperatorTerm
              ? new Terms.OperatorTerm({ operator: "+" })
              : { class: "OperatorTerm", operator: "+" };
            const numTerm = Terms.NumericTerm
              ? new Terms.NumericTerm({ number: spec.offset })
              : { class: "NumericTerm", number: spec.offset, total: spec.offset, evaluate: () => spec.offset };

            this.terms.push(opTerm, numTerm);

            this._formula = null; // will re-cache it immediately after
            this.__pf2eHB_offsetApplied = true;
          }

          // IMPORTANT: re-cache a *string* formula so serialization doesn’t write null
          try { this._formula = this.formula; } catch { /* best effort */ }

        } catch (e) {
          console.warn("[pf2e-homebrew-crits] evaluate patch: term injection failed:", e);
        }

        // Run original method
        const out = evalOrig[name].apply(this, args);

        // Keep spec tag for downstream consumers/logging
        try { if (spec && !this.__pf2eHB_spec) this.__pf2eHB_spec = { ...spec }; } catch { }

        return out;
      };

      proto[name].__pf2eHB_patched = true;
    }

    evaluatePatched = true;
  }



  // ---- Register wrapper ----
  // Concurrency-safe: always push to swapStack (null when no swap) so parallel rolls can't
  // inherit another roll's spec. Install patches only when a swap might occur.
  register(async function wrapper(wrapped, check, context = {}, event2 = null, callback) {
    try {
      const rawActor = context?.actor ?? check?.actor ?? null;
      const actor = Utils.actorDoc(rawActor);
      const { kind, rank } = StatDetection.fromPreRoll(actor, context, check);

      const baseSpec = Proficiency.shouldApplyDieSwap(kind, actor, rank)
        ? Proficiency.specForRank(rank)
        : null;

      if (baseSpec) {
        installDiePatch();
        installFromTermsPatch();
        installFromFormulaPatch();
        installEvaluatePatch();

        // CRITICAL: Inject spec into context so Roll.fromTerms can find it
        if (!context._pf2eHB) context._pf2eHB = {};
        context._pf2eHB.spec = { ...baseSpec, _offsetApplied: false };
      }

      swapStack.push(baseSpec ? { ...baseSpec, _offsetApplied: false } : null);

      if (SettingsCache.get("discoveryMode")) {
        console.log("[pf2e-homebrew-crits] DieSwap pre:", {
          kind, rank, spec: baseSpec, slug: check?.slug, type: context?.type, actorType: actor?.type
        });
      }

      try {
        return await wrapped(check, context, event2, callback);
      } finally {
        swapStack.pop();
        if (swapStack.length === 0) {
          removeFromTermsPatch();
          removeFromFormulaPatch();
          removeEvaluatePatch();
          removeDiePatch();
        }
      }
    } catch (e) {
      console.warn("[pf2e-homebrew-crits] DieSwap wrapper failed:", e);
      return await wrapped(check, context, event2, callback);
    }
  }); // <-- closes libWrapper.register(...)
}); // <-- closes Hooks.once("ready", () => { ... })
